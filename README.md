### **Визуализация графов**  

#### **1. Задача**  
Есть библиотека pycomsdk, которая реализует парсинг и обход графа описанного в формате aDOT. 
Данная библиотека использует еще одну библиотеку comsdk, написанную на языке C++, с помощью данной библиотеки производяться ресурсозатратные расчеты,
асинхронное выполнение обхода графа и.т.д.
На сегодняшний день pycomsdk работает следующим образом: парсит граф, обходит его и в случае если в описании графа указано асинхронное выполнение какой-то части графа,
то по ssh отправляет данные в библиотеку comsdk, которая выполняет асинхронные или ресурсоемкие вычисления.

Необходимо реализовать визуализацию графа:  
- Отображение иерархии (узлы → подграфы → узлы внутри них)  
- Интерактивность (переход по клику на подграф)  
- Масштабирование для больших структур  
- Экспорт и импорт  

#### **2. Выбранный подход**  
**Graphviz + Django Admin**  
- **Graphviz** – мощный инструмент для визуализации графов, поддерживающий:  
  - Вложенные подграфы (`subgraph`)  
  - Гибкую настройку стилей (цвета, формы узлов, стрелки)  
  - Автоматическую компоновку (алгоритмы `dot`, `fdp` для больших графов)  
- **Django Admin** – кастомизация через:  
  - Генерацию SVG с кликабельными областями  
  - Динамическую подгрузку данных  
  - Интеграцию с моделями  

---

### **3. Ключевые компоненты решения**  

#### **А. Модели данных**  
- **Граф (`Graph`)** – основной объект, может быть вложенным (`parent`).  
- **Узел (`Node`)** – принадлежит графу, может ссылаться на подграф (`subgraph`).  
- **Связь (`Edge`)** – соединяет узлы в рамках одного графа.  

#### **Б. Генерация графа**  
1. **Рекурсивный обход**  
   - Каждый граф отрисовывается как `subgraph` (если он вложенный) или как основной граф.  
   - Узлы без подграфов – простые элементы, узлы с подграфами – контейнеры (`cluster`).  

2. **Стилизация**  
   - Подграфы: серый фон с рамкой, название = имени узла.  
   - Терминальные узлы: зеленый фон, обычные – синий.  
   - Связи: подписи, стрелки, особые правила для соединения подграфов.  

3. **Оптимизация для больших графов**  
   - При >50 узлах автоматически переключается алгоритм компоновки (`fdp`).  
   - Упрощенные связи (`splines=ortho` – прямые линии).  

#### **В. Интерактивность в админке**  
- **SVG с картой ссылок**  
  - Подграфы становятся кликабельными (переход на страницу подграфа в Django Admin).   
- **Масштабирование**  
  - SVG встраивается в `<object>` с прокруткой для больших графов.  
- **Навигация**  
  - Кнопка «← Родительский граф» для возврата на уровень выше.  

#### **Г. Экспорт**  
Помимо формата aDOT
- Поддержка форматов:  
  - **PNG** – для изображений.  
  - **PDF** – для документов.  
- Генерация через `graphviz` без промежуточных файлов (бинарные данные → HTTP-ответ).  

---

### **4. Необходимо предусмотреть**
#### **Расширяемость**  
- Добавить:  
  - Логику подсветки путей.   
  - Визуализацию хода выполнения.  

---

### **5. Один из проблемных моментов**  

#### ⚠️ **Каким способом передавть данные между библиотекми, с тем учетом, что они могут быть запущены на разных машинах**  
- **Проблема**: (`ssh`) имеет низкую скорость передачи данных и очень низкоуровнево (нужно самому управлять соединением).  

#### Предлагаемое решение ZeroMQ + MsgPack**:  

ZeroMQ — это библиотека для асинхронной передачи сообщений через сокеты (поддерживает TCP, IPC, multicast).

- Не требует центрального брокера (в отличие от RabbitMQ/Kafka).

- Гибкие паттерны: PUSH/PULL, PUB/SUB, REQ/REP.

MsgPack — бинарный сериализатор, аналог JSON, но быстрее и компактнее.

- Поддержка в Python (msgpack-python) и C++ (msgpack-c).

Плюсы:
- Минимальная задержка (данные передаются почти как сырые байты).
- Гибкость (можно передавать любые структуры: списки, словари, графы).
- Простота (легче gRPC, нет .proto-файлов).

Минусы:
- Нужно вручную контролировать целостность данных.